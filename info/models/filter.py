# Фильтрация данных
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Good.objects.filter(category__name__in = ["Метлы", "Щетки"], in_stock = True)
# Здесь мы выбираем только те метлы и щетки, что есть в наличии.

Good.objects.exclude(category__name__in = ["Метлы", "Щетки"], in_stock = True)
# Здесь мы исключаем те метлы и щетки, что есть в наличии.

Good.objects.filter(price__lte = 100).exclude(in_stock = False)
# А здесь выбираем товары, которые стоят 100 руб. и дешевле, 
# после чего исключаем те из них, что отсутствуют в наличии.

Good.objects.order_by("name")
# Здесь мы сортируем товары по их названиям.

Good.objects.order_by("category__name", "-price", "name")
# А здесь - товары сначала по названию категории, потом по 
# убыванию цены и, на­конец, по названию самого товара.

# Не принимающий параметров метод reverse диспетчера записей 
# возвращает список записей, порядок сортировки которых 
# противоположен по отношению к изначаль­ному:
goods = goods.reverse()

Good.objects.get(name = "Суперметла")
# Здесь мы получаем товар «Суперметла».


# :::::::::::::::::::::::::::::::::::
# полезные методы

exists() 
# Возвращает True, если набор содержит записи, и False в 
# противном случае

first() 
# Возвращает объект первой записи списка или None, если 
# список пуст

last() 
# Возвращает объект последней записи списка или None, если
# список пуст

earliest(<поле>) 
# Возвращает объект записи с наименьшим значением параметра
# поле, которое должно иметь тип даты или даты и времени

latest(<поле>) 
# Возвращает объект записи с наибольшим значением параметра
# поле, которое должно иметь тип даты или даты и времени

distinct([<cпиcoк имен полей, разделенных запятыми>]) 
# Возвращает набор, включающий лишь уникальные записи. Если
# не указан список полей, в набор включаются записи, в которых
# значения всех полей являются уникальными. Если список полей
# присутствует, в набор включаются записи, в которых 
# уникальными являются лишь значения указанных нами полей


if Good.objects.filter(pk=2).exists():
    good = Good.objects.get(pk=2)
# Здесь мы проверяем, есть ли в модели запись с заданным нами 
# идентификатором, и, если есть, извлекаем ее.

Good.objects.filter(in_stock=False).first()
# Здесь мы получаем первый товар из тех, что отсутствуют в наличии.

Blog.objects.all().distinct()
# А здесь - набор уникальных статей блога.

Blog.objects.all().distinct("pub_date", "title")
# Здесь мы получаем набор статей блога, в которых уникальными 
# являются лишь дата nубликации и заголовок.







# :::::::::::::::::::::::::::::::::::
# любой тип данных

exact 
# Значение поля должно быть равно указанному (это поведение 
# по умолчанию, так что данный модификатор можно не указывать)

in 
# Значение поля должно быть равно одному из указанных. 
# Сравниваемые значения задаются в виде списка

isnull 
# Поле должно (True) или не должно (False) содержать какое-либо
# значение


# :::::::::::::::::::::::::::::::::::
# для строк

iexact 
# То же самое, что exact, но без учета регистра символов

contains 
# Значение поля должно содержать указанное нами

icontains 
# То же самое, что conta'ins, но без учета регистра символов

startswith 
# Значение поля должно начинаться с указанного нами

istartswith 
# То же самое, что startswi th, но без учета регистра символов

endswith 
# Значение поля должно заканчиваться указанным нами

iendswith 
# То же самое, что endswith, но без учета регистра символов


# ::::::::::::::::::::::::::::::::::::
# для чисел

gt 
# Значение поля должно быть больше указанного

gte 
# Значение поля должно быть больше или равно указанному

lt 
# Значение поля должно быть меньше указанного

lte 
# Значение поля должно быть меньше или равно указанному


# ::::::::::::::::::::::::::::::::::::
# число, дата, время, дата и время

range 
# Значение поля должно укладываться в указанный нами диапазон, 
# который задается в виде кортежа


# ::::::::::::::::::::::::::::::::::::
# дата, дата и время

year 
# Значение поля должно принадлежать к указанному нами году

month 
# Значение поля должно принадлежать к указанному нами месяцу

day 
# Значение поля должно принадлежать к указанному нами числу

week_day 
# Значение ПОЛЯ ДОЛЖНО принадлежать к указанному нами дню
# недели, который задается числом от 1 (воскресенье) до 7 
# (суббота)


# :::::::::::::::::::::::::::::::::::
# время, дата и время

hour 
# Значение поля должно принадлежать к указанному нами часу

minute 
# Значение поля должно принадлежать к указанной нами минуте

second 
# Значение поля должно принадлежать к указанной нами секунде



# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Мы можем сравнить значение одного поля со значением другого. 
# Для этого мы ис­пользуем класс django.dЬ.models.F:
from django.dЬ.models import F

BlogArticle.objects.filter(pubdate__lt = F("savedate"))
# Здесь мы отбираем статьи блога, значение поля savedate которых 
# больше значения поля pubdate, т.е. статьи, которые правились 
# после публикации.



# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Если нам надо найти все статьи блога, опубликованные за 2014 
# год или имеющие в заго­ловке слово «Django». В таких случаях 
# нам понадобится класс Q, объявленный в модуле django.dЬ.models:
from django.dЬ.models import Q

# Что касается логических операторов, то они аналогичны операторам 
# Python, но записываются по-другому: & аналогичен оператору and, 
# | - or, а ~ - not. Для группировки критериев мы можем 
# использовать круглые скобки:

BlogArticle.objects.filter(~Q(pubdate__range=(date(2014, 1, 1), date(2014, 1, 31))))
# Здесь мы выбираем статьи блога, дата публикации которых не 
# укладывается в про­межуток с 1 по 31 января 2014 года.

BlogArticle.objects.filter(Q(pubdate__year=2014) | Q(title__contains="Django"))
# А здесь - статьи блога, либо опубликованные в 2014 году, либо 
# содержащие в за­головке слово «Django».
