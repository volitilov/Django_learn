Реализация разграничения доступа

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Проверка, выполнил ли пользователь вход на сайт

# Во многих случаях требуется всего лишь проверить, выполнил ли пользователь
# успешный вход на сайт. В таком случае мы можем использовать декоратор 
# login_required, объявленный в модуле django.contrib.auth.decorators.
# Этот декоратор проверяет, выполнил ли посетитель вход на сайт, и только 
# после этого разрешает ему зайти на соответствующую контроллеру страницу. 
# Если же пользователь не выполнил процедуру входа, Django перенаправит его 
# на страницу входа, чей интернет-адрес указан в переменной LOGIN_URL настроек 
# проекта. При этом функции-контроллеру login будет передан интернет-адрес 
# страни­цы, на которую пытался войти посетитель, для чего будет использован 
# GЕТ-параметр с именем next.
# В случае использования классов-контроллеров мы укажем этот декоратор прямо
# в соответствующей привязке интернет-адреса - в модуле urls. Сам вызов 
# декора­тора ставится во втором параметре функции url, а вызов метода as_view 
# класса­ контроллера задается единственным его параметром

from django.contrib.auth.decorators import login_required

url(r'^(?P<cat_id>\d+)/add/$', login_required(GoodCreate.as_view()), name="good_add")
# Здесь мы указали, что для вызова класса-контроллера добавления нового товара
# в список, пользователь должен выполнить вход на сайт.

# Если же мы используем функции-контроллеры, то все еще проще. Мы вставим вы­
# зов декоратора login_required перед первой строкой объявления нужной функции:

@login_required
def good_create(request, cat_id):


# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Проверка, имеет ли пользователь необходимые права

# Несколько сложнее проверить, имеет ли пользователь права, необходимые для 
# вы­полнения той или иной операции. Для этого понадобится выяснить имя 
# соответст­вующего права.Django сама создает права, основываясь на всех 
# входящих в состав приложений проекта моделях. Эти права имеют внутренние
# имена вида:

<имя приложения>.<действие>_<имя модели>
# где действие: add - добавление, change - изменение и delete - удаление.

# Например, право page.add_good дает пользователю возможность добавлять 
# товары в список, а право page.delete_category - право удалять категории.

# Воспользуемся декоратором permission_required, также объявленным в модуле 
# django.contrib.auth.decorators. Он проверяет, выполнил ли пользователь вход 
# на сайт и имеет ли он право, внутреннее имя которого указано единственным 
# пара­метром этого декоратора в виде строки. В остальном он работает так же, 
# как уже знакомый нам декоратор login_required.

# Разработчики, применяющие классы-контроллеры, вставят вызов этого декоратора
# также в привязках интернет-адресов - непосредственно перед вызовом метода 
# as_view класса-контроллера, а сам вызов этого метода заключат в круглые 
# скобки:

from django.contrib.auth.decorators import permission_required

urlpatterns = [
    url(r'^(?P<cat_id>\d+)/add/$', 
        permission_required("page.add_good")(GoodCreate.as_view()), 
        name="good_add"),
    url(r'^good/(?P<good_id>\d+)/edit/$', 
        permission_required("page.change_good")(GoodUpdate.as_view()), 
        name="good_edit"),
    url(r'^good/(?P<good_id>\d+)/delete/$', 
    permission_required("page.delete_good")(GoodDelete.as_view()), 
    name="good_delete"),
]
# Здесь мы указываем, что для выполнения операций добавления, изменения и 
# уда­ления товара пользователь должен иметь соответствующие права.


# Поклонники функций-контроллеров просто вставят вызов декоратора перед 
# первой строкой объявления функции:
@permission_required("page.add_good")
def good_create(request, cat_id):


# Объект класса нttpRequest, хранящий сведения о запросе и получаемый в 
# качестве параметра любой функцией-контроллером и методами get и post 
# классов­ контроллеров, поддерживает свойство user. Это свойство хранит
# текущего пользователя в виде объекта класса user, объявленного в модуле
# django.contrib.auth.models, и неважно, является ли польз�ватель 
# зарегистрирован­ным или простым гостем (как мы уже успели заметить, 
# фактически класс user - это модель, и потом мы этим воспользуемся):

class GoodCreate(TemplateView):
    def get(self, request, *args, **kwargs):
        current_user = request.user

# Не принимающий параметров метод is_authenticated класса User возвращает 
# True, если пользователь выполнил успешный вход:

def get(self, request, *args, **kwargs):
    if request.user.is_authenticated(): pass
    else:
        return redirect("login")
# Здесь мы проверяем, выполнил ли пользователь вход, и, если не выполнил, 
# перена­правляем его на страницу входа.

# Чтобы передать функции-контроллеру login интернет-адрес страницы, на 
# которую должно быть выполнено перенаправление после успешного входа, мы 
# применим GЕТ-параметр next. Интернет-адрес текущей страницы хранится в 
# свойстве path объекта сведений о запросе:

def get(self, request, *args, **kwargs):
    if request.user.is_authenticated(): pass
    else:
        return redirect("/login/?next=" + request.path)
# Здесь мы указываем функции-контроллеру login после входа выполнить 
# возврат на нужную страницу. 

# Класс user поддерживает еще два полезных для нас метода. Они позволят 
# нам про­верить, имеет ли пользователь определенные права.
    has_perm() 
    # принимает в качестве параметра строку с внутренним именем права и 
    # возвращает тrue, если пользователь им обладает. Причем в этом случае 
    # проверяются не только права непосредственно пользователя, но и все 
    # права, ко­торыми обладают все группы, членом которых является 
    # пользователь:
    def get(self, request, *args, **kwargs):
        if request.user.is_authenticated():
            if request.user.has_perm("page.add_good"): pass
            else:
                return redirect("/login/?next=" + request.path)
        else:
            return redirect("/login/?next=" + request.path)
    # Здесь мы дополнительно проверяем, имеет ли пользователь, выполнивший 
    # вход на сайт, право на добавление товаров.

    has_perms() 
    # работает так же, но в качестве параметра принимает список строк с 
    # наименованиями прав и проверяет, имеет ли пользователь все эти права:
    def get(self, request, *args, **kwargs):
        if request.user.is_authenticated():
            if request.user.has perms(["page.add_good", 
                "page.change_good", "page.delete_good"]): pass
            else:
                return redirect("/login/?next=" + request.path)
        else:
            return redirect("/login/?next=" + request.path)
    # Здесь мы дополнительно проверяем, имеет ли пользователь права на 
    # добавле­ние, правку и удаление товаров.


# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Выполнение проверки в шаблонах

# Django в любом случае неявно создает в контексте данных шаблона переменные 
# user и perms, хранящие, соответственно, текущего пользователя и его права.
# Для проверки, выполнил ли пользователь вход на сайт, мы применим знакомый
# метод is_authenticated. Поскольку он не принимает параметров, мы можем 
# вы­звать его в коде шаблона:
{% if user.is_authenticated %}
    <td><a href="{% url "good_edit" good_id=good.id %}">Изменить</а></td>
    <td><a href="{% url "good_delete" good_id=good.id %}">Удалить</а></td>
{% endif %}
# Здесь мы выводим столбцы списка товаров с гиперссылками Изменить и Удалить,
# только если пользователь выполнил успешный вход.

# Значение переменной perms представляет собой объект, поддерживающий набор 
# свойств с именами вида:
<имя приложения>.<действие>_<имя модели>
# где действие: add - добавление, change - изменение и delete - удаление. 
# Каждое из этих свойств хранит значение тrue, если пользователь обладает 
# соответствую­щим правом:
{% if perms.page.add_good %}
    <р><а href="{% url "good_add" cat_id=category.id %}">Добавить товар</а></р>
{% endif %}
# Здесь мы выводим гиперссылку Добавить товар только в том случае, если 
# пользо­ватель имеет право на добавление товара.
